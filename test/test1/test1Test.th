#include "cxxtest/TestSuite.h"

#include "comms/iterator.h"
#include "test1/Message.h"
#include "test1/frame/Frame.h"
#include "cc_asn1/options/DefaultOptions.h"

class TestSuite : public CxxTest::TestSuite
{
public:
    void test1();
    void test2();

    using Interface =
        test1::Message<
            comms::option::app::IdInfoInterface,
            comms::option::app::ReadIterator<const std::uint8_t*>,
            comms::option::app::WriteIterator<std::uint8_t*>,
            comms::option::app::LengthInfoInterface,
            comms::option::app::ValidCheckInterface,
            comms::option::app::NameInterface,
            comms::option::app::RefreshInterface
        >;

    using Options = test1::options::DefaultOptionsT<cc_asn1::options::DefaultOptions>;

    using Msg1 = test1::message::Msg1<Interface, Options>;
    using Msg2 = test1::message::Msg2<Interface, Options>;

    using Frame = test1::frame::Frame<Interface, test1::input::AllMessages<Interface, Options>, Options>;
    using MsgPtr = Frame::MsgPtr;

    MsgPtr readWriteTest(const std::uint8_t* buf, std::size_t bufSize, comms::ErrorStatus expEs = comms::ErrorStatus::Success)
    {
        Frame frame;
        Frame::MsgPtr msgPtr;
        auto readIter = comms::readIteratorFor<Interface>(&buf[0]);
        auto es = frame.read(msgPtr, readIter, bufSize);
        TS_ASSERT_EQUALS(es, expEs);
        if (es != comms::ErrorStatus::Success) {
            TS_ASSERT(!msgPtr);
            return msgPtr;
        }

        TS_ASSERT(msgPtr);
        std::vector<std::uint8_t> outBuf;
        outBuf.resize(frame.length(*msgPtr));
        auto writeIter = comms::writeIteratorFor<Interface>(&outBuf[0]);
        es = frame.write(*msgPtr, writeIter, outBuf.size());
        TS_ASSERT_EQUALS(es, comms::ErrorStatus::Success);
        TS_ASSERT_EQUALS(outBuf.size(), bufSize);
        TS_ASSERT(std::equal(outBuf.begin(), outBuf.end(), buf));        
        return msgPtr;
    }
};

void TestSuite::test1()
{
    do {
        static const std::uint8_t Buf[] = {
            0x1, // MsgId.M1
            0x1, // Length.Short
        };
        static const auto BufSize = std::extent<decltype(Buf)>::value;

        auto msgPtr = readWriteTest(Buf, BufSize);
        TS_ASSERT(msgPtr);

        auto* msg1 = dynamic_cast<Msg1*>(msgPtr.get());
        TS_ASSERT(msg1 != nullptr);
        TS_ASSERT_EQUALS(msg1->field_length().getValue(), 1U);
    } while (false);

    do {
        static const std::uint8_t Buf[] = {
            0x1, // MsgId.M1
            0x82, // Length.Short
            0x01, 0x00 // Length.Long
        };
        static const auto BufSize = std::extent<decltype(Buf)>::value;

        auto msgPtr = readWriteTest(Buf, BufSize);
        TS_ASSERT(msgPtr);

        auto* msg1 = dynamic_cast<Msg1*>(msgPtr.get());
        TS_ASSERT(msg1 != nullptr);
        TS_ASSERT_EQUALS(msg1->field_length().getValue(), 0x100);
    } while (false);    

    do {
        static const std::uint8_t Buf[] = {
            0x1, // MsgId.M1
            0x82, // Length.Short
            0x01,  // Length.Long (incomplete)
        };
        static const auto BufSize = std::extent<decltype(Buf)>::value;

        auto msgPtr = readWriteTest(Buf, BufSize, comms::ErrorStatus::NotEnoughData);
        TS_ASSERT(!msgPtr);
    } while (false);       

    do {
        static const std::uint8_t Buf[] = {
            0x1, // MsgId.M1
            0x89, // Length.Short
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09  // Length.Long (too long)
        };
        static const auto BufSize = std::extent<decltype(Buf)>::value;

        auto msgPtr = readWriteTest(Buf, BufSize, comms::ErrorStatus::InvalidMsgData);
        TS_ASSERT(!msgPtr);
    } while (false);    

    do {
        static const std::uint8_t Buf[] = {
            0x1, // MsgId.M1
            0xff, // Length.Short
        };
        static const auto BufSize = std::extent<decltype(Buf)>::value;

        auto msgPtr = readWriteTest(Buf, BufSize, comms::ErrorStatus::NotEnoughData);
        TS_ASSERT(!msgPtr);
    } while (false);   

    do {
        Msg1 msg;
        Frame frame;
        TS_ASSERT_EQUALS(frame.length(msg), 2U);

        msg.field_length().setValue(0x100);
        TS_ASSERT_EQUALS(frame.length(msg), 4U);
    } while (false);   

    do {
        Msg1 msg;
        msg.field_length().field_short().field_flag().setBitValue_longForm(true);
        TS_ASSERT(msg.doRefresh());
        TS_ASSERT(msg.field_length().field_long().doesExist());
        TS_ASSERT_EQUALS(msg.field_length().field_short().field_lenValue().getValue(), 0x1);
    } while (false);     
}

void TestSuite::test2()
{
    do {
        static const std::uint8_t Buf[] = {
            0x2, // MsgId.M2
            0x1, 0x1, 0xff, // Boolean
            0x2, 0x2, 0x01, 0x02, // Integer
            0x4, 0x4, 0x01, 0x02, 0x03, 0x04, // OctetString
            0x5, 0x0, // Null
            0xC, 0x5, 'h', 'e', 'l', 'l', 'o', // Utf8String
            0x13, 0x5, 'h', 'e', 'l', 'l', 'o', // PrintableString
            0x16, 0x5, 'h', 'e', 'l', 'l', 'o', // Ia5String
        };
        static const auto BufSize = std::extent<decltype(Buf)>::value;

        auto msgPtr = readWriteTest(Buf, BufSize);
        TS_ASSERT(msgPtr);

        auto* msg = dynamic_cast<Msg2*>(msgPtr.get());
        TS_ASSERT(msg != nullptr);
        TS_ASSERT(msg->field_boolean().field_value().isTrue());
        TS_ASSERT_EQUALS(msg->field_integer().field_value().value(), 0x0102);
        TS_ASSERT_EQUALS(msg->field_octetString().field_value().value(), std::vector<std::uint8_t>({0x01, 0x02, 0x03, 0x04}));
        TS_ASSERT_EQUALS(msg->field_utf8String().field_value().value(), std::string("hello"));
        TS_ASSERT_EQUALS(msg->field_printableString().field_value().value(), std::string("hello"));
        TS_ASSERT_EQUALS(msg->field_ia5String().field_value().value(), std::string("hello"));
    } while (false);
}
